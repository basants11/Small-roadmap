<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Engineer Roadmap</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 400% 400%;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Floating geometric shapes */
        .bg-shape {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            animation: float 6s ease-in-out infinite;
            z-index: -1;
        }

        .bg-shape:nth-child(1) {
            width: 60px; height: 60px; top: 10%; left: 5%;
            transform: rotate(45deg); animation-delay: 0s;
        }
        .bg-shape:nth-child(2) {
            width: 40px; height: 40px; top: 20%; right: 10%;
            border-radius: 50%; animation-delay: 2s;
        }
        .bg-shape:nth-child(3) {
            width: 80px; height: 30px; bottom: 30%; left: 8%;
            border-radius: 15px; animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-20px) rotate(120deg); }
            66% { transform: translateY(10px) rotate(240deg); }
        }

        .container {
            position: relative;
            width: 90vw;
            max-width: 1200px;
            height: 80vh;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .roadmap-tree {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 40px;
        }

        .tree-level {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: nodeEntrance 1s cubic-bezier(0.4, 0, 0.2, 1) both,
                       enhancedPulse 3s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            z-index: 10;
        }

        .tree-level::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            border-radius: 50%;
            z-index: -1;
            animation: rotate 4s linear infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tree-level:hover {
            transform: scale(1.2) translateY(-5px);
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.6),
                        0 0 30px rgba(102, 126, 234, 0.4);
            animation: bounceIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .tree-level:hover::before {
            opacity: 0.8;
        }

        .tree-level.particle-active::after {
            content: '';
            position: absolute;
            width: 4px; height: 4px;
            background: #fff;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            animation: particleFloat 2s ease-out infinite;
        }

        @keyframes nodeEntrance {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(50px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes enhancedPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 25px rgba(255, 255, 255, 0.6);
            }
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3) translateY(50px); }
            50% { transform: scale(1.05) translateY(-10px); }
            70% { transform: scale(0.9) translateY(2px); }
            100% { transform: scale(1.2) translateY(-5px); }
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes particleFloat {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(0) translateY(-30px);
                opacity: 0;
            }
        }

        .tree-level:nth-child(1) { top: 10%; left: 10%; animation-delay: 0.1s, 0s; }
        .tree-level:nth-child(2) { top: 15%; left: 25%; animation-delay: 0.3s, 0.2s; }
        .tree-level:nth-child(3) { top: 30%; left: 15%; animation-delay: 0.5s, 0.4s; }
        .tree-level:nth-child(4) { top: 35%; left: 35%; animation-delay: 0.7s, 0.6s; }
        .tree-level:nth-child(5) { top: 50%; left: 25%; animation-delay: 0.9s, 0.8s; }
        .tree-level:nth-child(6) { top: 55%; left: 45%; animation-delay: 1.1s, 1s; }
        .tree-level:nth-child(7) { top: 70%; left: 35%; animation-delay: 1.3s, 1.2s; }
        .tree-level:nth-child(8) { top: 75%; left: 55%; animation-delay: 1.5s, 1.4s; }
        .tree-level:nth-child(9) { top: 85%; left: 45%; animation-delay: 1.7s, 1.6s; }
        .tree-level:nth-child(10) { top: 90%; left: 70%; animation-delay: 1.9s, 1.8s; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            transform-origin: left center;
            animation: energyFlow 2s ease-in-out infinite,
                       linePulse 3s ease-in-out infinite alternate;
            overflow: hidden;
        }

        .connection-line::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.8) 50%,
                transparent 100%);
            animation: flow 1.5s ease-in-out infinite;
        }

        .connection-line::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 8px,
                rgba(255, 255, 255, 0.3) 8px,
                rgba(255, 255, 255, 0.3) 16px
            );
            animation: dashFlow 2s linear infinite;
        }

        @keyframes energyFlow {
            0%, 100% {
                background: linear-gradient(90deg, transparent, #fff, transparent);
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            }
            50% {
                background: linear-gradient(90deg, rgba(102, 126, 234, 0.6), #fff, rgba(240, 147, 251, 0.6));
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
            }
        }

        @keyframes linePulse {
            0% { opacity: 0.6; transform: scaleY(1); }
            100% { opacity: 1; transform: scaleY(1.5); }
        }

        @keyframes flow {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes dashFlow {
            0% { background-position: 0px 0px; }
            100% { background-position: 32px 0px; }
        }

        .line1 { top: 13%; left: 13%; width: 15%; transform: rotate(15deg); }
        .line2 { top: 23%; left: 28%; width: 12%; transform: rotate(-10deg); }
        .line3 { top: 33%; left: 18%; width: 20%; transform: rotate(25deg); }
        .line4 { top: 38%; left: 38%; width: 18%; transform: rotate(-15deg); }
        .line5 { top: 48%; left: 28%; width: 20%; transform: rotate(20deg); }
        .line6 { top: 53%; left: 48%; width: 15%; transform: rotate(-20deg); }
        .line7 { top: 68%; left: 38%; width: 18%; transform: rotate(15deg); }
        .line8 { top: 73%; left: 58%; width: 12%; transform: rotate(-25deg); }
        .line9 { top: 83%; left: 48%; width: 25%; transform: rotate(10deg); }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .tree-level:hover + .tooltip {
            opacity: 1;
        }

        .progress-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .progress-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049, #2196F3, #9C27B0);
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 3px;
            animation: progressShimmer 2s ease-in-out infinite;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%);
            animation: shimmer 1.5s ease-in-out infinite;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: white;
            font-weight: 600;
        }

        .percentage {
            background: linear-gradient(45deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: numberPulse 2s ease-in-out infinite;
        }

        .milestone-indicator {
            position: absolute;
            width: 2px; height: 12px;
            background: #fff;
            top: -3px;
            opacity: 0.8;
            animation: milestoneGlow 2s ease-in-out infinite;
        }

        @keyframes progressShimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes numberPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes milestoneGlow {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 3px rgba(255, 255, 255, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 8px rgba(255, 255, 255, 0.8); }
        }

        /* Ripple effect */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0);
            animation: rippleAnimation 0.6s linear;
            pointer-events: none;
        }

        @keyframes rippleAnimation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Drag and drop visual feedback */
        .tree-level.dragging {
            transform: scale(1.3) rotate(5deg);
            box-shadow: 0 15px 35px rgba(255, 255, 255, 0.8),
                        0 0 40px rgba(102, 126, 234, 0.6);
            z-index: 100;
        }

        .tree-level.drag-over {
            animation: dragPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes dragPulse {
            0% { transform: scale(1.1); }
            100% { transform: scale(1.15); }
        }

        /* Smooth transitions for state changes */
        .tree-level.state-changing {
            animation: stateTransition 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes stateTransition {
            0% { background: rgba(255, 255, 255, 0.9); }
            50% { background: rgba(102, 126, 234, 0.8); }
            100% { background: rgba(255, 255, 255, 1); }
        }

        /* Performance optimizations */
        .tree-level, .connection-line, .progress-bar {
            will-change: transform, opacity;
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .tree-level,
            .connection-line,
            .progress-bar,
            .bg-shape {
                animation: none;
                transition: none;
            }

            .tree-level::before,
            .tree-level::after {
                display: none;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .tree-level {
                border: 3px solid white;
            }

            .connection-line {
                background: white;
            }
        }

        @media (max-width: 768px) {
            .container {
                width: 95vw;
                height: 90vh;
            }

            .roadmap-tree {
                padding: 20px;
            }

            .tree-level {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }

            .progress-indicator {
                width: 200px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating background shapes -->
    <div class="bg-shape"></div>
    <div class="bg-shape"></div>
    <div class="bg-shape"></div>

    <div class="container">
        <div class="roadmap-tree">
            <div class="tree-level">1</div>
            <div class="tree-level">2</div>
            <div class="tree-level">3</div>
            <div class="tree-level">4</div>
            <div class="tree-level">5</div>
            <div class="tree-level">6</div>
            <div class="tree-level">7</div>
            <div class="tree-level">8</div>
            <div class="tree-level">9</div>
            <div class="tree-level">0</div>

            <div class="connection-line line1"></div>
            <div class="connection-line line2"></div>
            <div class="connection-line line3"></div>
            <div class="connection-line line4"></div>
            <div class="connection-line line5"></div>
            <div class="connection-line line6"></div>
            <div class="connection-line line7"></div>
            <div class="connection-line line8"></div>
            <div class="connection-line line9"></div>

            <div class="progress-indicator">
                <div class="progress-text">
                    <span>Progress</span>
                    <span class="percentage" id="percentage">0%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                    <div class="milestone-indicator" id="milestone25" style="left: 25%;"></div>
                    <div class="milestone-indicator" id="milestone50" style="left: 50%;"></div>
                    <div class="milestone-indicator" id="milestone75" style="left: 75%;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // RoadmapManager class for data operations
        class RoadmapManager {
            constructor(roadmapData) {
                this.data = roadmapData;
            }

            // Get node by ID
            getNodeById(id) {
                return this.data.nodes.find(node => node.id === id);
            }

            // Get all nodes
            getAllNodes() {
                return this.data.nodes;
            }

            // Get nodes by category
            getNodesByCategory(category) {
                return this.data.nodes.filter(node => node.category === category);
            }

            // Get nodes by difficulty
            getNodesByDifficulty(difficulty) {
                return this.data.nodes.filter(node => node.difficulty === difficulty);
            }

            // Get prerequisites for a node
            getPrerequisites(nodeId) {
                const node = this.getNodeById(nodeId);
                if (!node || !node.prerequisites.length) return [];

                return node.prerequisites.map(prereqId => this.getNodeById(prereqId))
                                       .filter(prereq => prereq !== undefined);
            }

            // Get recommended next nodes based on completed nodes
            getRecommendedNextNodes(completedNodeIds) {
                const completedSet = new Set(completedNodeIds);

                return this.data.nodes.filter(node => {
                    // Node not completed yet
                    if (completedSet.has(node.id)) return false;

                    // All prerequisites are completed
                    return node.prerequisites.every(prereqId => completedSet.has(prereqId));
                }).sort((a, b) => {
                    // Sort by number of prerequisites (fewer first)
                    const aPrereqs = a.prerequisites.length;
                    const bPrereqs = b.prerequisites.length;
                    if (aPrereqs !== bPrereqs) return aPrereqs - bPrereqs;

                    // Then by difficulty level
                    const difficultyOrder = { 'Beginner': 0, 'Intermediate': 1, 'Advanced': 2, 'Expert': 3 };
                    return difficultyOrder[a.difficulty] - difficultyOrder[b.difficulty];
                });
            }

            // Get available nodes (no prerequisites or all prerequisites completed)
            getAvailableNodes(completedNodeIds = []) {
                const completedSet = new Set(completedNodeIds);
                return this.data.nodes.filter(node =>
                    node.prerequisites.length === 0 || node.prerequisites.every(prereqId => completedSet.has(prereqId))
                );
            }

            // Calculate completion statistics
            getCompletionStats(completedNodeIds) {
                const completedSet = new Set(completedNodeIds);
                const totalNodes = this.data.nodes.length;
                const completedNodes = this.data.nodes.filter(node => completedSet.has(node.id));
                const completionPercentage = (completedNodeIds.length / totalNodes) * 100;

                // Calculate category completion
                const categoryStats = {};
                this.data.metadata.categories.forEach(category => {
                    const categoryNodes = this.getNodesByCategory(category);
                    const completedInCategory = categoryNodes.filter(node => completedSet.has(node.id));
                    categoryStats[category] = {
                        total: categoryNodes.length,
                        completed: completedInCategory.length,
                        percentage: categoryNodes.length > 0 ? (completedInCategory.length / categoryNodes.length) * 100 : 0
                    };
                });

                // Calculate difficulty distribution
                const difficultyStats = {};
                this.data.metadata.difficultyLevels.forEach(difficulty => {
                    const difficultyNodes = this.getNodesByDifficulty(difficulty);
                    const completedInDifficulty = difficultyNodes.filter(node => completedSet.has(node.id));
                    difficultyStats[difficulty] = {
                        total: difficultyNodes.length,
                        completed: completedInDifficulty.length,
                        percentage: difficultyNodes.length > 0 ? (completedInDifficulty.length / difficultyNodes.length) * 100 : 0
                    };
                });

                return {
                    totalNodes,
                    completedNodes: completedNodeIds.length,
                    completionPercentage: Math.round(completionPercentage * 100) / 100,
                    categoryStats,
                    difficultyStats,
                    completedNodes: completedNodes
                };
            }

            // Get learning path (recommended order)
            getLearningPath() {
                const path = [];
                const completedSet = new Set();
                const remainingNodes = [...this.data.nodes];

                while (remainingNodes.length > 0) {
                    // Find nodes that can be added next (all prerequisites completed)
                    const nextNodes = remainingNodes.filter(node =>
                        node.prerequisites.every(prereqId => completedSet.has(prereqId))
                    );

                    if (nextNodes.length === 0) {
                        // If no nodes can be added, add the one with fewest prerequisites
                        nextNodes.push(remainingNodes.reduce((min, node) =>
                            node.prerequisites.length < min.prerequisites.length ? node : min
                        ));
                    }

                    // Sort by difficulty and add to path
                    nextNodes.sort((a, b) => {
                        const difficultyOrder = { 'Beginner': 0, 'Intermediate': 1, 'Advanced': 2, 'Expert': 3 };
                        return difficultyOrder[a.difficulty] - difficultyOrder[b.difficulty];
                    });

                    const nextNode = nextNodes[0];
                    path.push(nextNode);
                    completedSet.add(nextNode.id);

                    // Remove from remaining nodes
                    const index = remainingNodes.findIndex(node => node.id === nextNode.id);
                    if (index > -1) {
                        remainingNodes.splice(index, 1);
                    }
                }

                return path;
            }
        }

        // ProgressManager class for localStorage integration
        class ProgressManager {
            constructor(storageKey = 'networkRoadmapProgress') {
                this.storageKey = storageKey;
                this.completedNodes = new Set(this.loadProgress());
            }

            // Load progress from localStorage
            loadProgress() {
                try {
                    const saved = localStorage.getItem(this.storageKey);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return Array.isArray(parsed) ? parsed : [];
                    }
                } catch (error) {
                    console.warn('Failed to load progress from localStorage:', error);
                }
                return [];
            }

            // Save progress to localStorage
            saveProgress() {
                try {
                    const progressArray = Array.from(this.completedNodes);
                    localStorage.setItem(this.storageKey, JSON.stringify(progressArray));
                    return true;
                } catch (error) {
                    console.warn('Failed to save progress to localStorage:', error);
                    return false;
                }
            }

            // Mark a node as completed
            completeNode(nodeId) {
                if (typeof nodeId !== 'number') {
                    console.warn('Node ID must be a number');
                    return false;
                }

                this.completedNodes.add(nodeId);
                return this.saveProgress();
            }

            // Mark a node as incomplete
            uncompleteNode(nodeId) {
                if (typeof nodeId !== 'number') {
                    console.warn('Node ID must be a number');
                    return false;
                }

                this.completedNodes.delete(nodeId);
                return this.saveProgress();
            }

            // Toggle node completion status
            toggleNode(nodeId) {
                if (this.isCompleted(nodeId)) {
                    return this.uncompleteNode(nodeId);
                } else {
                    return this.completeNode(nodeId);
                }
            }

            // Check if a node is completed
            isCompleted(nodeId) {
                return this.completedNodes.has(nodeId);
            }

            // Get all completed node IDs
            getCompletedNodes() {
                return Array.from(this.completedNodes);
            }

            // Get completion count
            getCompletedCount() {
                return this.completedNodes.size;
            }

            // Get completion percentage (requires total nodes)
            getCompletionPercentage(totalNodes) {
                if (totalNodes <= 0) return 0;
                return Math.round((this.completedNodes.size / totalNodes) * 10000) / 100; // Round to 2 decimal places
            }

            // Check if all nodes are completed
            isFullyCompleted(totalNodes) {
                return this.completedNodes.size >= totalNodes;
            }

            // Get recently completed nodes (last 5)
            getRecentlyCompleted() {
                // This would require storing timestamps, for now return last 5 completed
                return Array.from(this.completedNodes).slice(-5);
            }

            // Clear all progress
            clearProgress() {
                this.completedNodes.clear();
                try {
                    localStorage.removeItem(this.storageKey);
                    return true;
                } catch (error) {
                    console.warn('Failed to clear progress from localStorage:', error);
                    return false;
                }
            }

            // Export progress data
            exportProgress() {
                return {
                    completedNodes: Array.from(this.completedNodes),
                    completedCount: this.completedNodes.size,
                    exportDate: new Date().toISOString()
                };
            }

            // Import progress data
            importProgress(progressData) {
                if (progressData && Array.isArray(progressData.completedNodes)) {
                    this.completedNodes = new Set(progressData.completedNodes);
                    return this.saveProgress();
                }
                return false;
            }

            // Get progress statistics
            getProgressStats(totalNodes) {
                const completed = this.completedNodes.size;
                const percentage = this.getCompletionPercentage(totalNodes);

                return {
                    completed,
                    total: totalNodes,
                    percentage,
                    remaining: totalNodes - completed,
                    isComplete: completed >= totalNodes
                };
            }
        }

            // Create ripple effect
            function createRipple(event) {
                const ripple = document.createElement('div');
                const rect = event.target.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const x = event.clientX - rect.left - size / 2;
                const y = event.clientY - rect.top - size / 2;

                ripple.style.width = ripple.style.height = size + 'px';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.classList.add('ripple');

                event.target.appendChild(ripple);

                setTimeout(() => {
                    ripple.remove();
                }, 600);
            }

            // Particle effect on node activation
            function createParticleEffect(element) {
                element.classList.add('particle-active');

                setTimeout(() => {
                    element.classList.remove('particle-active');
                }, 2000);
            }

            // Milestone celebration
            function celebrateMilestone(milestone) {
                const indicator = milestoneIndicators[milestone];
                if (indicator) {
                    indicator.style.animation = 'milestoneGlow 1s ease-in-out';
                    indicator.style.background = '#4CAF50';

                    setTimeout(() => {
                        indicator.style.animation = 'milestoneGlow 2s ease-in-out infinite';
                        indicator.style.background = '#fff';
                    }, 1000);
                }
            }

            treeLevels.forEach((level, index) => {
                const nodeId = index + 1;
                const nodeData = roadmapManager.getNodeById(nodeId);

                // Create enhanced tooltip with rich metadata
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';

                // Create tooltip content with rich information
                tooltip.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px; color: #fff;">${nodeData.title}</div>
                    <div style="font-size: 10px; margin-bottom: 4px; opacity: 0.9;">${nodeData.difficulty} • ${nodeData.estimatedTime}</div>
                    <div style="font-size: 10px; margin-bottom: 4px; opacity: 0.8;">${nodeData.category}</div>
                    <div style="font-size: 10px; opacity: 0.7; line-height: 1.3;">${nodeData.description}</div>
                `;

                level.appendChild(tooltip);

                // Mark as completed if saved in progress
                if (progressManager.isCompleted(nodeId)) {
                    level.classList.add('active');
                }

                // Drag and drop functionality (visual feedback only)
                let isDragging = false;

                level.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    this.classList.add('dragging');
                });

                document.addEventListener('mousemove', function(e) {
                    if (isDragging) {
                        const rect = level.getBoundingClientRect();
                        level.style.left = ((e.clientX - rect.width / 2) / window.innerWidth * 100) + '%';
                        level.style.top = ((e.clientY - rect.height / 2) / window.innerHeight * 100) + '%';
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    if (isDragging) {
                        isDragging = false;
                        level.classList.remove('dragging');
                        // Reset position after drag
                        setTimeout(() => {
                            level.style.left = '';
                            level.style.top = '';
                        }, 300);
                    }
                });

                // Click interaction with enhanced animations
                level.addEventListener('click', function(e) {
                    // Create ripple effect
                    createRipple(e);

                    // Toggle active state with smooth transition
                    this.classList.add('state-changing');
                    setTimeout(() => {
                        this.classList.toggle('active');
                        this.classList.remove('state-changing');
                    }, 100);

                    // Update progress using ProgressManager
                    const nodeId = index + 1;
                    const wasCompleted = progressManager.isCompleted(nodeId);

                    if (this.classList.contains('active')) {
                        // Node is being marked as incomplete
                        progressManager.uncompleteNode(nodeId);
                        completedSteps--;
                        createParticleEffect(this);
                    } else {
                        // Node is being marked as complete
                        progressManager.completeNode(nodeId);
                        completedSteps++;
                    }

                    // Update progress bar and percentage using new system
                    const progress = progressManager.getCompletionPercentage(treeLevels.length);
                    updateProgress(progress);

                    // Check for milestones
                    if (progress >= 25 && progress < 50) celebrateMilestone(25);
                    else if (progress >= 50 && progress < 75) celebrateMilestone(50);
                    else if (progress >= 75) celebrateMilestone(75);
                });

                // Enhanced hover effects for tooltips
                level.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.top = '-50px';
                    tooltip.style.left = '50%';
                    tooltip.style.transform = 'translateX(-50%)';
                    this.style.zIndex = '20';

                    // Show additional node information in console for debugging
                    const nodeData = roadmapManager.getNodeById(nodeId);
                    console.log(`Node ${nodeId}: ${nodeData.title}`, {
                        description: nodeData.description,
                        difficulty: nodeData.difficulty,
                        category: nodeData.category,
                        prerequisites: nodeData.prerequisites,
                        completed: progressManager.isCompleted(nodeId)
                    });
                });

                level.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    this.style.zIndex = '10';
                });
            });

            // Enhanced progress update function
            function updateProgress(progress) {
                progressBar.style.width = progress + '%';
                percentage.textContent = Math.round(progress) + '%';

                // Color transition based on progress
                const hue = (progress / 100) * 120; // 0-120 (red to green)
                percentage.style.background = `linear-gradient(45deg, hsl(${hue}, 70%, 60%), hsl(${hue + 20}, 70%, 70%))`;
                percentage.style.backgroundClip = 'text';
                percentage.style.webkitBackgroundClip = 'text';
                percentage.style.webkitTextFillColor = 'transparent';
            }

            // Auto-progress animation with milestones (using new progress system)
            const autoProgressInterval = setInterval(() => {
                // Simulate completing nodes automatically for demo
                const currentCompleted = progressManager.getCompletedCount();
                if (currentCompleted < treeLevels.length) {
                    const nextNodeId = currentCompleted + 1;
                    progressManager.completeNode(nextNodeId);

                    const progress = progressManager.getCompletionPercentage(treeLevels.length);
                    updateProgress(progress);

                    // Trigger milestone celebrations during auto-progress
                    if (Math.floor(progress) === 25) celebrateMilestone(25);
                    if (Math.floor(progress) === 50) celebrateMilestone(50);
                    if (Math.floor(progress) === 75) celebrateMilestone(75);
                } else {
                    clearInterval(autoProgressInterval);
                }
            }, 2000); // Slower auto-progress for better demo experience

            // Display roadmap statistics
            function displayRoadmapStats() {
                const stats = roadmapManager.getCompletionStats(progressManager.getCompletedNodes());
                console.log('=== Network Engineer Roadmap Statistics ===');
                console.log(`Overall Progress: ${stats.completionPercentage}% (${stats.completedNodes}/${stats.totalNodes} nodes)`);
                console.log('Category Breakdown:');
                Object.entries(stats.categoryStats).forEach(([category, data]) => {
                    console.log(`  ${category}: ${data.completed}/${data.total} (${Math.round(data.percentage)}%)`);
                });
                console.log('Difficulty Breakdown:');
                Object.entries(stats.difficultyStats).forEach(([difficulty, data]) => {
                    console.log(`  ${difficulty}: ${data.completed}/${data.total} (${Math.round(data.percentage)}%)`);
                });
                console.log('Recently Completed:', progressManager.getRecentlyCompleted());
                console.log('========================================');
            }

            // Add keyboard shortcuts for debugging
            document.addEventListener('keydown', function(e) {
                switch(e.key.toLowerCase()) {
                    case 'r':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            if (confirm('Reset all progress? This cannot be undone.')) {
                                progressManager.clearProgress();
                                location.reload();
                            }
                        }
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            displayRoadmapStats();
                        }
                        break;
                    case 'e':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const exportData = progressManager.exportProgress();
                            console.log('Progress Export Data:', exportData);
                            alert('Progress data exported to console. Check browser dev tools.');
                        }
                        break;
                }
            });

            // Display initial statistics
            displayRoadmapStats();

            // Parallax effect for background shapes
            document.addEventListener('mousemove', function(e) {
                const shapes = document.querySelectorAll('.bg-shape');
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;

                shapes.forEach((shape, index) => {
                    const speed = (index + 1) * 0.02;
                    const x = (mouseX - 0.5) * 20 * speed;
                    const y = (mouseY - 0.5) * 20 * speed;

                    shape.style.transform = `translate(${x}px, ${y}px)`;
                });
            });
        });

        // Network engineering roadmap data with rich metadata
        const roadmapData = {
                "nodes": [
                    {
                        "id": 1,
                        "title": "OSI Model",
                        "description": "Understanding the 7-layer OSI model and how data flows through network layers",
                        "difficulty": "Beginner",
                        "estimatedTime": "2-3 hours",
                        "prerequisites": [],
                        "resources": [
                            "OSI Model documentation",
                            "Network+ study guides",
                            "Cisco networking basics"
                        ],
                        "category": "Fundamentals"
                    },
                    {
                        "id": 2,
                        "title": "TCP/IP Protocol Suite",
                        "description": "Master TCP/IP protocols, addressing, and subnetting fundamentals",
                        "difficulty": "Beginner",
                        "estimatedTime": "4-5 hours",
                        "prerequisites": [1],
                        "resources": [
                            "TCP/IP Illustrated",
                            "RFC 791 (IP)",
                            "RFC 793 (TCP)",
                            "Subnetting practice tools"
                        ],
                        "category": "Core Protocols"
                    },
                    {
                        "id": 3,
                        "title": "Subnetting & IP Addressing",
                        "description": "Learn subnetting techniques, VLSM, and CIDR notation",
                        "difficulty": "Intermediate",
                        "estimatedTime": "3-4 hours",
                        "prerequisites": [2],
                        "resources": [
                            "Subnet calculators",
                            "IP addressing workbooks",
                            "Cisco subnetting tutorials"
                        ],
                        "category": "IP Management"
                    },
                    {
                        "id": 4,
                        "title": "Routing Fundamentals",
                        "description": "Static and dynamic routing protocols (RIP, OSPF, EIGRP, BGP)",
                        "difficulty": "Intermediate",
                        "estimatedTime": "6-8 hours",
                        "prerequisites": [3],
                        "resources": [
                            "Cisco routing guides",
                            "OSPF documentation",
                            "BGP case studies",
                            "Network simulator tools"
                        ],
                        "category": "Routing"
                    },
                    {
                        "id": 5,
                        "title": "Switching Technologies",
                        "description": "Ethernet switching, VLANs, STP, and Layer 2 protocols",
                        "difficulty": "Intermediate",
                        "estimatedTime": "4-5 hours",
                        "prerequisites": [1, 2],
                        "resources": [
                            "Cisco switching fundamentals",
                            "STP explained",
                            "VLAN configuration guides"
                        ],
                        "category": "Layer 2"
                    },
                    {
                        "id": 6,
                        "title": "VLANs & Trunking",
                        "description": "VLAN design, trunking protocols, and inter-VLAN routing",
                        "difficulty": "Intermediate",
                        "estimatedTime": "3-4 hours",
                        "prerequisites": [5],
                        "resources": [
                            "802.1Q standard",
                            "VTP configuration",
                            "Layer 3 switching"
                        ],
                        "category": "Layer 2"
                    },
                    {
                        "id": 7,
                        "title": "Network Security",
                        "description": "Firewalls, VPNs, access control, and security best practices",
                        "difficulty": "Advanced",
                        "estimatedTime": "8-10 hours",
                        "prerequisites": [2, 4, 5],
                        "resources": [
                            "Cisco ASA guides",
                            "Firewall fundamentals",
                            "VPN configuration",
                            "Security+ certification"
                        ],
                        "category": "Security"
                    },
                    {
                        "id": 8,
                        "title": "Wireless Networks",
                        "description": "Wi-Fi standards, security, and enterprise wireless deployment",
                        "difficulty": "Advanced",
                        "estimatedTime": "5-6 hours",
                        "prerequisites": [2, 7],
                        "resources": [
                            "802.11 standards",
                            "Wi-Fi security guides",
                            "Cisco wireless controllers"
                        ],
                        "category": "Wireless"
                    },
                    {
                        "id": 9,
                        "title": "Network Monitoring",
                        "description": "SNMP, NetFlow, monitoring tools, and performance analysis",
                        "difficulty": "Advanced",
                        "estimatedTime": "4-5 hours",
                        "prerequisites": [4, 5],
                        "resources": [
                            "SNMP tutorials",
                            "SolarWinds guides",
                            "PRTG Network Monitor",
                            "Wireshark documentation"
                        ],
                        "category": "Operations"
                    },
                    {
                        "id": 10,
                        "title": "Network Automation",
                        "description": "Python scripting, Ansible, REST APIs, and infrastructure as code",
                        "difficulty": "Expert",
                        "estimatedTime": "10-12 hours",
                        "prerequisites": [4, 7, 9],
                        "resources": [
                            "Python for network engineers",
                            "Ansible playbooks",
                            "Cisco DevNet",
                            "NETCONF/YANG models"
                        ],
                        "category": "Automation"
                    }
                ],
                "metadata": {
                    "totalNodes": 10,
                    "categories": ["Fundamentals", "Core Protocols", "IP Management", "Routing", "Layer 2", "Security", "Wireless", "Operations", "Automation"],
                    "difficultyLevels": ["Beginner", "Intermediate", "Advanced", "Expert"],
                    "estimatedTotalTime": "50-65 hours"
                }
            };

            // Create ripple effect
            function createRipple(event) {
                const ripple = document.createElement('div');
                const rect = event.target.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const x = event.clientX - rect.left - size / 2;
                const y = event.clientY - rect.top - size / 2;

                ripple.style.width = ripple.style.height = size + 'px';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.classList.add('ripple');

                event.target.appendChild(ripple);

                setTimeout(() => {
                    ripple.remove();
                }, 600);
            }

            // Particle effect on node activation
            function createParticleEffect(element) {
                element.classList.add('particle-active');

                setTimeout(() => {
                    element.classList.remove('particle-active');
                }, 2000);
            }

            // Milestone celebration
            function celebrateMilestone(milestone) {
                const indicator = milestoneIndicators[milestone];
                if (indicator) {
                    indicator.style.animation = 'milestoneGlow 1s ease-in-out';
                    indicator.style.background = '#4CAF50';

                    setTimeout(() => {
                        indicator.style.animation = 'milestoneGlow 2s ease-in-out infinite';
                        indicator.style.background = '#fff';
                    }, 1000);
                }
            }

            treeLevels.forEach((level, index) => {
                const nodeId = index + 1;
                const nodeData = roadmapManager.getNodeById(nodeId);

                // Create enhanced tooltip with rich metadata
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';

                // Create tooltip content with rich information
                tooltip.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px; color: #fff;">${nodeData.title}</div>
                    <div style="font-size: 10px; margin-bottom: 4px; opacity: 0.9;">${nodeData.difficulty} • ${nodeData.estimatedTime}</div>
                    <div style="font-size: 10px; margin-bottom: 4px; opacity: 0.8;">${nodeData.category}</div>
                    <div style="font-size: 10px; opacity: 0.7; line-height: 1.3;">${nodeData.description}</div>
                `;

                level.appendChild(tooltip);

                // Mark as completed if saved in progress
                if (progressManager.isCompleted(nodeId)) {
                    level.classList.add('active');
                }

                // Drag and drop functionality (visual feedback only)
                let isDragging = false;

                level.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    this.classList.add('dragging');
                });

                document.addEventListener('mousemove', function(e) {
                    if (isDragging) {
                        const rect = level.getBoundingClientRect();
                        level.style.left = ((e.clientX - rect.width / 2) / window.innerWidth * 100) + '%';
                        level.style.top = ((e.clientY - rect.height / 2) / window.innerHeight * 100) + '%';
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    if (isDragging) {
                        isDragging = false;
                        level.classList.remove('dragging');
                        // Reset position after drag
                        setTimeout(() => {
                            level.style.left = '';
                            level.style.top = '';
                        }, 300);
                    }
                });

                // Click interaction with enhanced animations
                level.addEventListener('click', function(e) {
                    // Create ripple effect
                    createRipple(e);

                    // Toggle active state with smooth transition
                    this.classList.add('state-changing');
                    setTimeout(() => {
                        this.classList.toggle('active');
                        this.classList.remove('state-changing');
                    }, 100);

                    // Update progress using ProgressManager
                    const nodeId = index + 1;
                    const wasCompleted = progressManager.isCompleted(nodeId);

                    if (this.classList.contains('active')) {
                        // Node is being marked as incomplete
                        progressManager.uncompleteNode(nodeId);
                        completedSteps--;
                        createParticleEffect(this);
                    } else {
                        // Node is being marked as complete
                        progressManager.completeNode(nodeId);
                        completedSteps++;
                    }

                    // Update progress bar and percentage using new system
                    const progress = progressManager.getCompletionPercentage(treeLevels.length);
                    updateProgress(progress);

                    // Check for milestones
                    if (progress >= 25 && progress < 50) celebrateMilestone(25);
                    else if (progress >= 50 && progress < 75) celebrateMilestone(50);
                    else if (progress >= 75) celebrateMilestone(75);
                });

                // Enhanced hover effects for tooltips
                level.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.top = '-50px';
                    tooltip.style.left = '50%';
                    tooltip.style.transform = 'translateX(-50%)';
                    this.style.zIndex = '20';

                    // Show additional node information in console for debugging
                    const nodeData = roadmapManager.getNodeById(nodeId);
                    console.log(`Node ${nodeId}: ${nodeData.title}`, {
                        description: nodeData.description,
                        difficulty: nodeData.difficulty,
                        category: nodeData.category,
                        prerequisites: nodeData.prerequisites,
                        completed: progressManager.isCompleted(nodeId)
                    });
                });

                level.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    this.style.zIndex = '10';
                });
            });

            // Enhanced progress update function
            function updateProgress(progress) {
                progressBar.style.width = progress + '%';
                percentage.textContent = Math.round(progress) + '%';

                // Color transition based on progress
                const hue = (progress / 100) * 120; // 0-120 (red to green)
                percentage.style.background = `linear-gradient(45deg, hsl(${hue}, 70%, 60%), hsl(${hue + 20}, 70%, 70%))`;
                percentage.style.backgroundClip = 'text';
                percentage.style.webkitBackgroundClip = 'text';
                percentage.style.webkitTextFillColor = 'transparent';
            }

            // Auto-progress animation with milestones (using new progress system)
            const autoProgressInterval = setInterval(() => {
                // Simulate completing nodes automatically for demo
                const currentCompleted = progressManager.getCompletedCount();
                if (currentCompleted < treeLevels.length) {
                    const nextNodeId = currentCompleted + 1;
                    progressManager.completeNode(nextNodeId);

                    const progress = progressManager.getCompletionPercentage(treeLevels.length);
                    updateProgress(progress);

                    // Trigger milestone celebrations during auto-progress
                    if (Math.floor(progress) === 25) celebrateMilestone(25);
                    if (Math.floor(progress) === 50) celebrateMilestone(50);
                    if (Math.floor(progress) === 75) celebrateMilestone(75);
                } else {
                    clearInterval(autoProgressInterval);
                }
            }, 2000); // Slower auto-progress for better demo experience

            // Display roadmap statistics
            function displayRoadmapStats() {
                const stats = roadmapManager.getCompletionStats(progressManager.getCompletedNodes());
                console.log('=== Network Engineer Roadmap Statistics ===');
                console.log(`Overall Progress: ${stats.completionPercentage}% (${stats.completedNodes}/${stats.totalNodes} nodes)`);
                console.log('Category Breakdown:');
                Object.entries(stats.categoryStats).forEach(([category, data]) => {
                    console.log(`  ${category}: ${data.completed}/${data.total} (${Math.round(data.percentage)}%)`);
                });
                console.log('Difficulty Breakdown:');
                Object.entries(stats.difficultyStats).forEach(([difficulty, data]) => {
                    console.log(`  ${difficulty}: ${data.completed}/${data.total} (${Math.round(data.percentage)}%)`);
                });
                console.log('Recently Completed:', progressManager.getRecentlyCompleted());
                console.log('========================================');
            }

            // Add keyboard shortcuts for debugging
            document.addEventListener('keydown', function(e) {
                switch(e.key.toLowerCase()) {
                    case 'r':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            if (confirm('Reset all progress? This cannot be undone.')) {
                                progressManager.clearProgress();
                                location.reload();
                            }
                        }
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            displayRoadmapStats();
                        }
                        break;
                    case 'e':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const exportData = progressManager.exportProgress();
                            console.log('Progress Export Data:', exportData);
                            alert('Progress data exported to console. Check browser dev tools.');
                        }
                        break;
                }
            });

            // Display initial statistics
            displayRoadmapStats();

            // Parallax effect for background shapes
            document.addEventListener('mousemove', function(e) {
                const shapes = document.querySelectorAll('.bg-shape');
                const mouseX = e.clientX / window.innerWidth;
                const mouseY = e.clientY / window.innerHeight;

                shapes.forEach((shape, index) => {
                    const speed = (index + 1) * 0.02;
                    const x = (mouseX - 0.5) * 20 * speed;
                    const y = (mouseY - 0.5) * 20 * speed;

                    shape.style.transform = `translate(${x}px, ${y}px)`;
                });
            });
            });
</body>
</html>